/*
*浅分析JS的运行机制
* 1.当浏览器（它的内核\引擎）渲染和解析JS的时候，会提供一个供JS代码运行的环境，我们把这个环境称之为"全局作用域"（"global"/"window" scope）
*
* 2.代码自上而行执行（在此之前还有变量提升阶段）
*   =>基本类型的值会存储在当前作用域下    ==>栈内存（本身就是供JS代码运行的环境 所有的基本数据类型都会直接的在栈内存空间开辟一个位置进行存储）
*   var a = 12;
*   1)首先开辟一个空间12
*   2)在当前作用域中声明一个变量a(var a)
*   3)让声明的变量和存储的12进行关联（把存储的12赋值给a
*   =>赋值操作做叫做定义）
*
*   var b=a
*   b=>新的12；此时的a/b没有关系
*   基本数据类型（也叫做值类型），是按照值来操作的：把原来的值复制一份，放到新的空间或者位置上，和原来的值没有关系
*   b=13
*   新开辟一个空间存13，让b和13关联
*   如果空间没有被占用则被销毁=>原来和b关联的12被销毁
*---------------------------------------
*   =>引用数据类型的值不能直接存储在当前的作用域下（因为可能存储的内容过于复杂），
*   我们需要先开辟一个新的空间（理解为仓库），把内容存储到这个空间中      ==>堆内存（用来存储引用类型中的信息值的 对象存储的是键值对 函数存储的是代码字符串）
*   var obj1 = {n:100};
*   1)首先开辟一个新的内存空间，把对象中的键值对依次存储起来（为了保证后面可以找到这个空间，此空间有一个16进制的地址）
*   2）声明一个变量
*   3）让变量和空间地址关联在一起（把空间地址赋值给变量）
*   引用类型不是按照值来操作的，他操作的是空间的引用地址：把原来空间的地址复制个新的变量，但原来的空间没有被克隆，
*   还是一个空间，这样就会出现多个变量关联的相同的空间，相互之间就会存在影响了
*   var obj2 = obj1          =>公用一个空间
*   obj2["n"]=200;           =>obj1={n:200}
* */
----
课后练习
var obj = {
    n: 10,
    m: obj.n * 10
}
console.log(obj.m); //Uncaught TypeError: Cannot read property 'n' of undefined
/*
1.形成一个全局作用域（栈内存）
2.代码自上而下执行
3.1首先开辟一个新的堆内存（AAAFFF111），把键值对存储到堆内存中
    n:10
    m:obj.n*10 ->obj.n 是undefined，obj.n<->undefined.n
*/
var ary1 = [3, 4]; //首先开辟一个新的堆内存（AAAFFF111），把[3, 4]存储到堆内存中,把AAAFFF111存储到ary1中
var ary2 = ary1; //把AAAFFF111存储到ary2中
ary2[0] = 1; //现在ary1和ary2指向的是同一个内存地址，所以操作的是同一组数据->[1,4]
ary2 = [4, 5]; //开辟一个新的堆内存（AAAFFF222）,把[4, 5]存储到堆内存中,把AAAFFF222存储到ary2中
ary2[1] = 2; //[4,5]->[4,2]
ary1[1] = 0; //[1,4]->[1,0]

console.log(ary1, ary2)